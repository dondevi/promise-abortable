var AbortablePromise=function(){"use strict";function n(){const n=t(),o=t=>{if(n.aborted)return;n.aborted=!0;n.dispatchEvent(t)};return{signal:n,abort:o}}function t(){const n={aborted:!1,onabort:null};return n.dispatchEvent=(t=>{"function"==typeof n.onabort&&n.onabort(t)}),n}function o(n,t){t.onabort=(t=>{n.forEach(n=>{n instanceof r&&n.abort(t).catch(n=>n)})})}class r extends Promise{constructor(t,o=n()){super((n,r)=>{t(n,r,o.signal)}),this.abortController=o}then(n,t){return new r((o,e,i)=>{const c=(n,t,c)=>{if("function"==typeof c)return(t=c(t))instanceof r&&Object.assign(i,t.abortController.signal),o(t);"resolved"===n&&o(t);"rejected"===n&&e(t)};super.then(t=>c("resolved",t,n),n=>c("rejected",n,t))},this.abortController)}abort(n){return new r((t,o)=>{Promise.resolve().then(()=>{this.abortController.abort(n);this.then(t,o)})},this.abortController)}static all(n){return new r((t,r,e)=>{o(n,e);Promise.all(n).then(t,r)})}static race(n){return new r((t,r,e)=>{o(n,e);Promise.race(n).then(t,r)})}}return r}();
